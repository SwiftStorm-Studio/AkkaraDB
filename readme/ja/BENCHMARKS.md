# ベンチマーク

AkkaraDB v3のパフォーマンス測定結果です。

## 📚 目次

- [テスト環境](#テスト環境)
- [書き込みパフォーマンス](#書き込みパフォーマンス)
- [読み取りパフォーマンス](#読み取りパフォーマンス)
- [混合ワークロード](#混合ワークロード)
- [スケーラビリティ](#スケーラビリティ)
- [チューニングガイド](#チューニングガイド)
- [総合評価](#総合評価)

---

## テスト環境

### ハードウェア

| 項目               | 仕様                                           |
|:-----------------|:---------------------------------------------|
| **CPU**          | Intel Core i5-12500H (12 cores, 2.5-4.5 GHz) |
| **Memory**       | 64 GB DDR4-3200                              |
| **Storage**      | NVMe SSD (T-FORCE Z44A5, 2TB)                |
| Sequential Read  | 4,500 MB/s                                   |
| Sequential Write | 4,500 MB/s                                   |
| Random Read 4K   | 1,000k IOPS                                  |
| Random Write 4K  | 1,000k IOPS                                  |
| **OS**           | Windows 11 (23H2/22631.5335)                 |

### ソフトウェア

| 項目              | バージョン                                                                                   |
|:----------------|:----------------------------------------------------------------------------------------|
| **JDK**         | OpenJDK 21.0.1                                                                          |
| **Kotlin**      | 2.2.21                                                                                  |
| **AkkaraDB**    | v0.2.9 (v3)                                                                             |
| **JVM Options** | `-Xmx4G -XX:+UseG1GC -XX:+AlwaysPreTouch -XX:MaxGCPauseMillis=50 -Dfile.encoding=UTF-8` |

### ベンチマーク設定

```kotlin
// 共通設定
val keyCount = 100_000  // 特記なき場合
val valueSize = 64      // bytes
val threads = 1         // シングルスレッド測定

// データベース設定（特記なき場合）
AkkaraDB.Options(
    k = 4,
    m = 2,
    walGroupN = 512,
    walGroupMicros = 50_000,
    walFastMode = true,
    stripeFastMode = true
)
```

---

## 書き込みパフォーマンス

### WAL Group Commit チューニング

WALのグループコミット設定による影響を測定しました（100,000 keys, 64B values）。

| # | WalGroupN | WalGroupMicros |    ops/sec | p50 (µs) | p90 (µs) |   p99 (µs) | 備考              |
|--:|----------:|---------------:|-----------:|---------:|---------:|-----------:|:----------------|
| ① |        64 |          1,000 |      4,004 |      5.9 |     16.1 | **15,279** | fsync過多（完全同期律速） |
| ② |       128 |          5,000 |      8,204 |      3.3 |      8.3 |       36.5 | 明確に高速化          |
| ③ |       128 |         10,000 |      8,201 |      4.4 |      8.9 |       38.8 | 時間駆動バッチが安定化     |
| ④ |       256 |          1,000 |     16,137 |      4.6 |      7.5 |       24.2 | バッチ効果顕著         |
| ⑤ |       256 |         10,000 |     16,170 |      2.8 |      6.4 |       22.7 | バランス型           |
| ⑥ |       512 |         10,000 | **31,869** |      3.0 |      5.5 |   **16.8** | **最高スループット**    |
| ⑦ |       512 |         50,000 |     30,660 |      2.9 |      5.0 |       17.5 | 推奨設定            |

**グラフ: p99レイテンシ vs WalGroupN**

```
p99 (µs)
15000 |  ①
      |
 1000 |
      |
  100 |
      |    ②③
   50 |       ④⑤
      |          ⑥⑦
    0 +----+----+----+----+
      64  128  256  512
           WalGroupN
```

**結論:**

- **スループット**: WalGroupN にほぼ線形にスケール
- **WalGroupN=64**: fsync過多でp99が15ms超
- **最適設定**: `WalGroupN=512, WalGroupMicros=10,000`
  - スループット: ≈ 32k ops/s
  - p99: ≈ 17 µs
- **推奨設定**: `WalGroupN=512, WalGroupMicros=50,000`
  - 耐久性ウィンドウ: 50ms
  - スループット/レイテンシのバランス良好

---

### キー数によるスケーラビリティ

キー数を増やした場合の影響を測定しました。

|  キー数 | 書き込み時間 | ops/sec | p50 (µs) | p99 (µs) | 備考        |
|-----:|-------:|--------:|---------:|---------:|:----------|
|  10k |  0.28s |  37,597 |      2.8 |     12.1 | ウォームアップ段階 |
| 100k |  3.15s |  32,639 |      3.0 |     17.2 | 安定動作      |
|   1M | 32.07s |  32,193 |      3.5 |     18.7 | 線形スケール維持  |

**結論:**

- 1M キーまで完全に線形スケール
- スループットは32k ops/sec で安定
- p99は18µs以下を維持

---

### バリューサイズによる影響

バリューサイズを変化させた場合の影響を測定しました（100,000 keys）。

| ValueSize | ops/sec | p50 (µs) | p99 (µs) | スループット (MB/s) |
|----------:|--------:|---------:|---------:|--------------:|
|      16 B |  31,958 |      3.1 |     20.2 |           0.5 |
|      64 B |  38,022 |      3.4 |     24.5 |           2.3 |
|     256 B |  29,442 |      6.3 |     22.7 |           7.2 |
|      1 KB |  29,670 |      9.4 |     28.3 |          29.0 |
|      4 KB |  22,445 |     25.0 |     50.2 |          87.7 |
|     16 KB |  10,643 |     78.2 |    153.7 |         166.3 |

**結論:**

- 小サイズ（≤256B）: ops/sec 30k前後で安定
- 64B が最高スループット（38k ops/sec）
- 大サイズ（≥4KB）: コピーコストが支配的
- 16KB: スループット166 MB/sを達成

---

## 読み取りパフォーマンス

### MemTable vs SST

| データパス    | ベンチマーク   |  キー数 | ValueSize |     ops/sec | p50 (µs) | p90 (µs) | p99 (µs) | 備考            |
|:---------|:---------|-----:|----------:|------------:|---------:|---------:|---------:|:--------------|
| MemTable | read     | 100k |      64 B | **538,656** |  **1.3** |  **3.6** |  **6.2** | メモリヒット（I/Oなし） |
| SST      | read-sst | 100k |      64 B | **108,196** |  **7.6** | **12.7** | **22.3** | ディスクI/O発生     |

**レイテンシ詳細（MemTable）:**

| パーセンタイル | レイテンシ (µs) |
|--------:|-----------:|
|     p50 |        1.3 |
|     p75 |        2.5 |
|     p90 |        3.6 |
|     p95 |        4.1 |
|     p99 |        6.2 |
|   p99.9 |       15.8 |
|  p99.99 |       49.9 |
|     max |      150.5 |

**レイテンシ詳細（SST）:**

| パーセンタイル | レイテンシ (µs) |
|--------:|-----------:|
|     p50 |        7.6 |
|     p75 |        8.8 |
|     p90 |       12.7 |
|     p95 |       15.0 |
|     p99 |       22.3 |
|   p99.9 |       73.1 |
|  p99.99 |      218.8 |
|     max |     9851.0 |

**結論:**

- **MemTableヒット**: 54万 ops/sec、p99: 6.2µs
- **SSTヒット**: 11万 ops/sec、p99: 22.3µs
- どちらも要件（p99 ≤ 50µs）を大幅にクリア

---

### Bloomフィルター効果

存在しないキーを検索した場合のBloomフィルター効果を測定しました。

| 検索タイプ           |     ops/sec | p50 (µs) | p99 (µs) | False Positive率 |
|:----------------|------------:|---------:|---------:|----------------:|
| Negative lookup | **673,753** |  **1.2** |  **6.3** |       **0.00%** |
| Positive lookup |     108,196 |      7.6 |     22.3 |               — |

**レイテンシ詳細（Negative lookup）:**

| パーセンタイル | レイテンシ (µs) |
|--------:|-----------:|
|     p50 |        1.2 |
|     p75 |        1.4 |
|     p90 |        1.8 |
|     p95 |        2.4 |
|     p99 |        6.3 |
|   p99.9 |       19.6 |
|  p99.99 |      103.5 |
|     max |      186.9 |

**結論:**

- Bloomフィルターにより **6.2倍** 高速化（108k → 674k ops/sec）
- False Positive率: 0.00%（理論値1%より優秀）
- 存在しないキーの検索はディスクI/O不要で即座にreject

---

### 範囲検索パフォーマンス

```kotlin
// 範囲検索の例
// rangeはSequence<MemRecord>を返す
db.range(startKey, endKey).forEach { rec ->
  // process
}
```

| 範囲サイズ |    総時間 | 平均/エントリ (µs) |
|------:|-------:|-------------:|
|   100 |  12 ms |        123.8 |
|    1k |   8 ms |          8.5 |
|   10k |  51 ms |          5.1 |
|  100k | 507 ms |          5.1 |

**結論:**

- 範囲サイズに線形スケール
- 大きな範囲ほど効率的（≈5.1 µs/エントリ）
- 小さな範囲は初期化オーバーヘッドが相対的に大きい

---

## 混合ワークロード

### Read/Write比率による影響

| Read % | Write % |    総ops/sec | Read p99 (µs) | Write p99 (µs) |
|-------:|--------:|------------:|--------------:|---------------:|
|    100 |       0 | **295,457** |          10.5 |              — |
|     80 |      20 |     155,324 |          10.2 |           26.7 |
|     50 |      50 |      61,024 |          10.4 |           27.2 |
|     20 |      80 |      35,455 |          11.2 |           27.5 |
|      0 |     100 |      30,971 |             — |           26.1 |

**結論:**

- 読み取り比率が高いほど全体スループット向上
- Read p99 は比率に関わらず安定（10-11µs）
- Write p99 も比率に関わらず安定（26-28µs）
- ロック競合の影響は軽微

---

## スケーラビリティ

### マルチスレッドスケーラビリティ

書き込みワークロードでのマルチスレッド性能を測定しました。

| スレッド数 | ops/sec | スケール比 |   効率 |
|------:|--------:|------:|-----:|
|     1 |  32,507 | 1.00x | 100% |
|     2 |  31,825 | 0.98x |  49% |
|     4 |  30,905 | 0.95x |  24% |
|     8 |  30,714 | 0.94x |  12% |
|    16 |  30,705 | 0.94x |   6% |

**結論:**

- 書き込みはWAL fsyncがボトルネックでスケールしない
- スレッド数を増やしてもスループットは維持（劣化なし）
- 読み取りワークロードではより良好なスケーリングが期待できる

---

## Typed API (AkkDSL) パフォーマンス

シリアライゼーションオーバーヘッドを含むTyped APIの性能を測定しました（10,000 keys）。

| モード        | Write ops/sec | Write p99 (µs) | Read ops/sec | Read p99 (µs) |
|:-----------|--------------:|---------------:|-------------:|--------------:|
| NORMAL     |         3,952 |       13,454.6 |       45,058 |          45.2 |
| FAST       |        15,909 |           92.6 |       49,811 |          37.3 |
| ULTRA_FAST |        28,681 |           72.8 |       46,408 |          39.7 |

**結論:**

- ULTRA_FAST モードで raw API の約90%の性能を達成
- シリアライゼーションオーバーヘッドは軽微（≈3µs/op）
- 読み取りは全モードで45k+ ops/sec

---

## バッファプール統計

ベンチマーク終了時のプール統計：

```
Pool stats: Stats(hits=20,840,475, misses=3,886, created=3,886, dropped=0, retained=2,510)
```

| 指標       |          値 | 説明          |
|:---------|-----------:|:------------|
| hits     | 20,840,475 | プールからの取得成功  |
| misses   |      3,886 | 新規割り当て      |
| created  |      3,886 | 作成されたバッファ総数 |
| dropped  |          0 | プール満杯で破棄    |
| retained |      2,510 | プール内保持数     |

**ヒット率: 99.98%**

---

## チューニングガイド

### 書き込みテール改善

**目標:** p99レイテンシを下げる

**手法:**

#### 1. WalGroupNを増やす（バッチ効果）

```kotlin
AkkaraDB.Options(
    walGroupN = 512  // デフォルト: 64
)
```

#### 2. WalGroupMicrosを調整（耐久性とのトレードオフ）

```kotlin
AkkaraDB.Options(
    walGroupMicros = 50_000  // 50ms
)
```

#### 3. FastModeを有効化

```kotlin
AkkaraDB.Options(
  walFastMode = true,      // fdatasync使用
    stripeFastMode = true
)
```

**効果:**

| 指標       |       改善前 |       改善後 |
|:---------|----------:|----------:|
| p99レイテンシ | 15,279 µs |     17 µs |
| スループット   |  4k ops/s | 32k ops/s |

---

### 読み取りテール改善

**目標:** キャッシュミス時のレイテンシを下げる

**手法:**

#### 1. Bloomフィルターを有効化（デフォルト有効）

```kotlin
AkkaraDB.Options(
  bloomFPRate = 0.01  // デフォルト
)
```

#### 2. データをMemTableに保持

- フラッシュ閾値を上げてMemTableヒット率を向上
- メモリ使用量とのトレードオフ

**効果:**

| データパス        |    p99 |
|:-------------|-------:|
| MemTable     |  6.2µs |
| SST          | 22.3µs |
| Bloom reject |  6.3µs |

---

## 総合評価

### 目標達成状況

| 指標           | 目標 v3       | 達成値                     |    評価    |
|:-------------|:------------|:------------------------|:--------:|
| **書き込み P99** | ≤ 200 µs    | **≈ 17 µs**             | ✅ **達成** |
| **読み取り P99** | ≤ 50 µs     | **≈ 6 µs (MemTable)**   | ✅ **達成** |
|              |             | **≈ 22 µs (SST)**       | ✅ **達成** |
| **持続スループット** | ≥ 10k ops/s | **≈ 32k ops/s (write)** | ✅ **達成** |
|              |             | **≈ 540k ops/s (read)** | ✅ **達成** |
| **クラッシュセーフ** | WAL + fsync | ✅ 検証済み                  | ✅ **達成** |

### 結論

AkkaraDB v3は**プロダクショングレード**のパフォーマンスを達成しました：

- ✅ 書き込み p99: 17µs（要件200µsの**12倍**の余裕）
- ✅ 読み取り p99: 6.2µs（要件50µsの**8倍**の余裕）
- ✅ 完全非同期、クラッシュセーフ
- ✅ 線形スケーラビリティ（1M keys）
- ✅ バッファプールヒット率 99.98%

### 今後の最適化領域

- [ ] マルチスレッドコンパクション
- [ ] ブロックキャッシュの明示的管理
- [ ] インデックス/Bloomのメモリピン
- [ ] 適応的WALグループコミット
- [ ] 読み取りワークロードのマルチスレッドスケーリング

---

次へ: [ビルド](./BUILD.md) | [API リファレンス](./API_REFERENCE.md)

[概要に戻る](./ABOUT.md)

---